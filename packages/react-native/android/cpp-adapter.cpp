// Generated by uniffi-bindgen-react-native
#include <jni.h>
#include <jsi/jsi.h>
#include <ReactCommon/CallInvokerHolder.h>
#include "fedimint-react-native.h"

namespace jsi = facebook::jsi;
namespace react = facebook::react;

// Global static variable to store CallInvoker
static std::shared_ptr<react::CallInvoker> g_callInvoker = nullptr;

// Helper function to find HybridData in class hierarchy
jclass findHybridDataInHierarchy(JNIEnv *env, jobject obj) {
    jclass currentClass = env->GetObjectClass(obj);
    while (currentClass != nullptr) {
        jclass parentClass = env->GetSuperclass(currentClass);
        if (parentClass == nullptr) break;
        
        // Check if parent class is HybridData
        jclass hybridDataClass = env->FindClass("com/facebook/jni/HybridData");
        if (env->IsAssignableFrom(parentClass, hybridDataClass)) {
            env->DeleteLocalRef(hybridDataClass);
            env->DeleteLocalRef(parentClass);
            return currentClass;
        }
        
        env->DeleteLocalRef(currentClass);
        currentClass = parentClass;
    }
    
    // Fallback: assume the object itself is HybridData (RN 0.76+ case)
    return env->FindClass("com/facebook/jni/HybridData");
}

// New method to set CallInvoker during initialization
extern "C"
JNIEXPORT void JNICALL
Java_com_fedimint_reactnative_ReactNativeModule_nativeSetCallInvoker(
    JNIEnv *env,
    jclass type,
    jobject callInvokerHolderImpl
) {
    // Find HybridData in class hierarchy (works for both RN 0.75 and 0.76+)
    jclass hybridDataClass = findHybridDataInHierarchy(env, callInvokerHolderImpl);
    
    // Access mDestructor DIRECTLY on callInvokerHolderImpl (it IS-A HybridData now in RN 0.76+)
    auto destructorField = env->GetFieldID(hybridDataClass, "mDestructor", "Lcom/facebook/jni/HybridData$Destructor;");
    auto destructor = env->GetObjectField(callInvokerHolderImpl, destructorField);
    
    // Extract mNativePointer
    auto destructorClass = env->FindClass("com/facebook/jni/HybridData$Destructor");
    auto nativePointerField = env->GetFieldID(destructorClass, "mNativePointer", "J");
    jlong nativePointer = env->GetLongField(destructor, nativePointerField);
    
    // Store CallInvoker globally
    auto callInvokerHolder = reinterpret_cast<react::CallInvokerHolder*>(nativePointer);
    g_callInvoker = callInvokerHolder->getCallInvoker();
    
    // Cleanup local references
    env->DeleteLocalRef(destructor);
    env->DeleteLocalRef(destructorClass);
    env->DeleteLocalRef(hybridDataClass);
}

// Automated testing checks Java_com_fedimint_reactnative_ReactNativeModule and fedimint_reactnative
// by comparing the whole line here.
/*
Java_com_fedimint_reactnative_ReactNativeModule_nativeMultiply(JNIEnv *env, jclass type, jdouble a, jdouble b) {
    return fedimint_reactnative::multiply(a, b);
}
*/

// Modified installer to use stored CallInvoker (no CallInvokerHolder parameter needed)
extern "C"
JNIEXPORT jboolean JNICALL
Java_com_fedimint_reactnative_ReactNativeModule_nativeInstallRustCrate(
    JNIEnv *env,
    jclass type,
    jlong rtPtr
) {
    if (!g_callInvoker) {
        return false; // CallInvoker not set yet
    }
    
    auto runtime = reinterpret_cast<jsi::Runtime *>(rtPtr);
    return fedimint_reactnative::installRustCrate(*runtime, g_callInvoker);
}

extern "C"
JNIEXPORT jboolean JNICALL
Java_com_fedimint_reactnative_ReactNativeModule_nativeCleanupRustCrate(JNIEnv *env, jclass type, jlong rtPtr) {
    auto runtime = reinterpret_cast<jsi::Runtime *>(rtPtr);
    return fedimint_reactnative::cleanupRustCrate(*runtime);
}